NOTE: This file is no longer being updated. See the CHANGES file in
      the top-level directory.


Changes since version 3.2.0
---------------------------     

- Added demo book/lifecycle.

- Ant Slice tasks now accept a property, ice.home. This property
  performs the same function as the ICE_HOME environment variable.

- Fixed object adapter activation deadlock. The deadlock could occur
  if another thread invokes concurrently on the locator while the
  adapter is registering its endpoints with the locator registry.
  
- Fixed a bug in IceSSL that could cause a NullPointerException when
  using TrustOnly properties.

- Added support for protected class data members using the new
  metadata tag ["protected"]. The tag can be applied to a Slice class
  or to individual data members.

- Changed the throughput demo to better support cross-language
  testing.

- Fixed throughput performance problem on Windows that would occur
  when sending large requests.

- Added Ice.TCP.RcvSize and Ice.TCP.SndSize properties. These
  properties control the size of the TCP receive and send buffers for
  the TCP and SSL transports.

- Fixed a bug in IceSSL for JDK 1.5 that could cause a hang during
  the SSL handshake.

- Added support for opaque endpoints. For example:

  opaque -t 2 -v CTEyNy4wLjAuMREnAAD/////AA==

  This is the same as:

  ssl -h 127.0.0.1 -p 10001

  The "opaque" protocol identifier indicates an unknown protocol.
  Both the -t and the -v option must be present:

  -t <num>:    Indicates the protocol type (TCP = 1, SSL = 2, UDP = 3).

  -v <base64>: Provides the value of the opaque endpoint. The option
               argument is the marshaled representation of the
               endpoint (including the endpoint's enclosing
               encapsulation) in base64 encoding.

  This syntax is useful if, for example, a client that has the SSL
  plug-in configured sends a proxy with an SSL endpoint to a server
  without the SSL plug-in. Prior to this version, the server would
  drop the unknown SSL endpoint when it stringified the proxy.
  As of this version, the server preserves the endpoint and, when the
  server stringifies a proxy containing an unknown endpoint, it uses
  the above opaque syntax.

- Trailing characters past the adapter id in a stringified proxy
  will now raise a ProxyParseException.

- Fixed the translator to correctly generate marshaling/unmarshaling
  methods for interfaces and allow them to be transferred by value.

- Fixed a translator bug that generated invalid code for certain
  Java5 types.

Changes since version 3.1.1
---------------------------     

- createObjectAdapter() and propertyToProxy() print warnings if
  unknown properties are found during creation of the adapter or
  proxy. These warnings can be disabled by setting the property
  Ice.Warn.UnknownProperties=0.

- Added the property Ice.Default.EndpointSelection. If not defined,
  the default value is "Random".

- Proxies and object adapters can now be configured to use
  thread-per-connection.

- IceBox services no longer inherit the properties of the container
  by default. If this is the desired behavior set the property
  IceBox.InheritProperties to 1.

- The default mapping for Ice is now the Java 5 mapping. To use the
  Java 2 mapping, you must define the new "java:java2" global
  metadata. See the Ice manual for more information.

- Added Communicator::isShutdown() and ObjectAdapter::isDeactivated()
  to allow applications to determine whether a communicator has been
  shutdown or an object adapter has been deactivated, respectively.

- Added destroy() operation to the ObjectAdapter interface. This
  operation must be called in order to reclaim the adapter's resources
  and be able to recreate a new adapter with the same name. Destroying
  a communicator automatically calls destroy on all of its adapters.

- Added a per-process logger and two methods to get/set the logger,
  Ice.Util.getProcessLogger() and Ice.Util.setProcessLogger(). Calling
  getProcessLogger() creates a default logger if setProcessLogger()
  has not been called. The process logger is also used as the default
  logger for all communicators that do not have a logger explicitly
  set.

- Added support for shutdown hooks to Ice.Application. See the Ice
  manual for more information on the setInterruptHook method.

- Message batches are now automatically flushed when the total size of
  the batch reaches the message size maximum. This feature can be
  controlled using the Ice.BatchAutoFlush property, which is on by
  default.

- During the creation of an object adapter, the communicator now
  raises InitializationException if the adapter has no configuration.
  It is possible to create an adapter with no configuration, which
  is useful for bidirectional connections, by passing an empty string
  as the argument to createObjectAdapter.

- Fixed a bug in IceSSL for Java2 that would reject incoming
  connections if IceSSL.CheckCertName=1 was defined in a server.

- It is now possible to start and stop individual IceBox services
  using the IceBox admin utility.

- Added Communicator::propertyToProxy() which creates a proxy from
  a set of properties. This operation allows you to set various local
  proxy settings, such as the locator cache timeout, which cannot be
  set using stringToProxy().

- The Ice.Logger.Timestamp property has been removed. Timestamps are
  now always printed.

- Added the property Ice.Default.PreferSecure, which if set to 1
  causes secure endpoints to be preferred over non-secure endpoints.
  By default this property is set to 0. Also added functions to
  control this behavior on a per-proxy rather than global basis:
  ice_isPreferSecure() and ice_preferSecure().

- Added a demo to illustrate use of AMI/AMD.

- IceBox services are now stopped in the reverse order from which they 
  were started.

- If a proxy does not specify a hostname (via -h HOST), the client
  only attempts to connect to the loopback interface (127.0.0.1).

- Attempts to change the attributes of a fixed proxy now result in a
  FixedProxyException rather than just ignoring the change request and
  returning the same proxy. Also, attempts to marshal a fixed proxy
  now result in a FixedProxyException rather than a MarshalException.

- Added support for implicit request contexts. When you invoke an
  operation on a proxy and don't pass an explicit context, Ice uses
  the "implicit context" combined with the per-proxy context (if any).
  You can obtain the implicit context using the new communicator
  operation getImplicitContext(). Three implementations of implicit
  context are available; you select one by setting the property
  Ice.ImplicitContext to one of the following values:

  * None: No implicit context at all (default).
  * PerThread: The implementation maintains a context per thread.
  * Shared: The implementation maintains a single thread-safe context
    that is shared by all threads.

- Removed defaultContext from InitializationData.

- Communicator::setDefaultContext(), Communicator::getDefaultContext()
  and Proxy::ice_defaultContext() have been deprecated.

- For object adapters without endpoints, Ice.Trace.Network >= 2 now
  prints a trace message.

- Added Ice.Override.Secure which forces a client to only use
  secure connections.

- Added more tracing to the IceSSL plug-in to aid in using the
  TrustOnly properties.

- Removed support for the IceBox.ServiceManager.Identity property,
  which was deprecated in Ice 3.0. The IceBox service supports an
  InstanceName property that should be used instead.

- Added UnexpectedObjectException. This exception is raised if you
  use Slice classes and client and server are compiled with mismatched
  Slice definitions. Alternatively, this exception is raised if you
  use dynamic invocation and pass a class of the wrong type as an
  operation parameter.

- Added the Freeze property Freeze.Evictor.UseNonmutating.

  When set to a non-zero value, the Freeze Evictor behaves like it did
  in previous Ice releases in that it assumes nonmutating operations
  do not update the target object, while all other operations do
  update the target.

  As of this release, the recommended mechanism is to use the
  "freeze:read" and "freeze:write" metadata (see below).

  If not defined, the default value of this property is 0.

- New Slice metadata for operations:

  - ["freeze:read"] or ["freeze:write"] marks the operation as "read"
    or "write" for the Freeze evictor. The default is the Freeze mode
    of the enclosing interface/class.

  - ["nonmutating"] provides backward compatibility for idempotent
    operations that were previously declared using the deprecated
    'nonmutating' keyword. You can replace the 'nonmutating' keyword
    with '["nonmutating"] idempotent' to maintain compatibility with
    objects implemented using Ice 3.0 or 3.1.

- New Slice metadata for interfaces/classes:

  - ["freeze:read"] or ["freeze:write"] defines the default Freeze
    mode for operations on the interface/class. The default is read.
    This metadata has no effect on derived types.

Changes since version 3.1.0
---------------------------

- Fixed a bug with the IceGrid allocate and sessionAllocation demos 
  where the session would not be destroyed in the event of an 
  allocation failure.

- Fixed a bug in IceSSL that caused a NullPointerException if a
  certificate did not contain subjectAltName extensions.

- Restored Communicator::setDefaultContext.

Changes since version 3.0.1
---------------------------

- IceSSL on AIX requires IBMJSSE2. See the INSTALL file for details.

- Removed removeObjectFactory() from the communicator interface.

- ObjectAdapter::deactivate() now notifies the locator registry when
  the adapter is deactivated.

- Fixed ObjectAdapter::activate() to activate the object adapter
  only if it is able to register its endpoints and process proxy with
  the locator. Calling activate() again retries a failed registration.

- Removed getDefaultProperties() functions, and the global default
  properties. If you need global properties, you can easily create
  your own global variable.

- Added new createProperties() functions:

  public static Properties
  createProperties(StringSeqHolder args, Properties defaults)

  public static Properties
  createProperties(String[] args, Properties defaults)
 
  where "defaults" represents an optional set of default properties
  used to initialize the new Properties object. Ice properties 
  defined on the command line and properties defined in a
  configuration file override these default properties.

- Generating new streaming functions for Slice struct and enum types.
  The ice_write and ice_read member functions replace their internal
  equivalents (__write and __read).

- Fixed a bug where the proxy timeout, compress flag and connection
  id attributes would be ignored for direct proxies using a router.

- Added ability to configure Ice thread start/stop hooks through
  InitializationData.

- Added identityToString and stringToIdentity to the Communicator
  interface.

- Added an SSL plug-in for Java5 that supports the thread pool
  concurrency model.

- Added support for specifying an alternate abstract type in
  metadata using the following syntax:

  ["java:type:concrete-type:abstract-type"] ...

  The abstract type is optional; if not specified, the translator
  selects a suitable default. Consider this example:

  ["java:type:java.util.LinkedList:java.util.List"]
  sequence<string> StringSeq;

  The translator maps StringSeq to the abstract type java.util.List
  except when the value must be instantiated, in which case the
  translator uses the concrete type java.util.LinkedList.

  Existing applications that use custom type metadata may require
  modification to comply with the new abstract type semantics.

- Added a Java5 mapping. When enabled, a Slice enum is mapped to a
  native Java enum and a dictionary is mapped to a generic type.
  The mapping is enabled using the new global metadata "java:java5".
  This metadata can also be defined on the translator command line
  using the new --meta option, which applies the metadata to every
  Slice file processed by the translator.

  The default Java5 mapping for a dictionary is java.util.Map<K,V>
  (abstract) and java.util.HashMap<K,V> (concrete). A custom
  type specified via metadata must implement java.util.Map<K,V>.

  The default Java5 mapping for a sequence remains unchanged.
  However, if a custom type is defined for a sequence, it must
  implement java.util.List<E>. If an abstract type is not defined,
  the translator uses java.util.List<E> by default.

  It is not possible to use the Java5 mapping selectively. If you
  elect to use the mapping, you must use it for all of your Slice
  definitions, and the resulting generated code can no longer be
  compiled with JDK 1.4. Furthermore, all custom type metadata must
  be converted to use Java5 generic types.

- Removed support for the deprecated "java:CustomType" metadata
  syntax. The required format is "java:type:CustomType".

- It is now possible to recreate a new object adapter with the same 
  name as an old adapter once waitForDeactivate() has completed on the
  old adapter.

- Added new operation Communicator::createObjectAdapterWithRouter(),
  which creates a routed object adapter. An object adapter may now
  be associated with at most one router, which is defined using this
  operation or by setting the <AdapterName>.Router property. Also
  as a result of this change, the ObjectAdapter::addRouter() and
  ObjectAdapter::removeRouter() operations have been removed.

- Modified the generated code to avoid a warning from Eclipse.

- Added communicator initialize functions that take an argument of
  type Ice.InitializationData. This class contains communicator
  members that may only be set during communicator initializations.
  Currently included are Properties, Logger, Stats, default context
  and the thread hooks. The initializeWithXXX initialization functions
  have been deprecated and the setLogger(), setStats() and
  setDefaultContext() operations have been removed.

- Added the new Slice metadata "deprecate" that can be used to
  qualify operations. The Slice-to-Java compiler translates this
  into an equivalent javadoc comment.

- Added a new operation addProxies() to Ice::Router, which can return
  evicted proxies. The old operation addProxy() is now deprecated.
  Note that this is an internal interface for communications between
  clients and routers (such as Glacier2).

- Fixed a bug where the ice_locator proxy method wouldn't change the
  proxy locator.

- The ice_timeout and ice_compress proxy methods now correctly
  override the timeout and compress flag of indirect proxy endpoints.

- Added proxy methods ice_isSecure, ice_getLocator, ice_getRouter,
  ice_isCollocationOptimized.

- Deprecated the following proxy methods:

  ice_hash
  ice_communicator
  ice_collocationOptimization
  ice_connection
  ice_newIdentity
  ice_newFacet
  ice_newContext
  ice_newAdapterId
  ice_newEndpoints

  These methods will be removed in the next major release. You should
  use the new methods shown below:

  ice_getHash
  ice_getCommunicator
  ice_collocationOptimized
  ice_getConnection
  ice_identity
  ice_facet
  ice_context
  ice_adapterId
  ice_endpoints

- Added requestId to Current, which allows a servant to determine
  whether an operation was invoked with collocated, oneway or twoway
  semantics. The requestId member is 0 for oneway invocations and
  -1 for collocated invocations.

- AMI invocations will now reuse the connection cached with the
  proxy instead of always looking up an existing connection for
  each invocation. As a side effect of this change, AMI invocations 
  on a proxy with collocation optimization enabled will now raise
  Ice::CollocationOptimizationException.

- Added the property Ice.Default.LocatorCacheTimeout and the proxy
  method ice_locatorCacheTimeout(). If a cached endpoint is older
  than the configured cache timeout, the Ice runtime won't use
  the cached endpoint. Instead, the Ice runtime will query the
  Ice locator service to retrieve up-to-date endpoints and then update
  the locator cache. Please see the Ice manual for more information.

- Added the proxy method ice_endpointSelection, which allows an
  application to control how endpoints are selected at connection
  establishment. Two endpoint selection types are currently supported:
  Random and Ordered.

- Added the proxy method ice_connectionCached. This method allows you
  to enable or disable the caching of the connection by the proxy. By
  default, the proxy will cache the connection to avoid looking it up
  for each request. Disabling the connection caching is useful to do
  per-request load balancing: the proxy will select a connection for
  each request and the request will eventually be sent to different 
  servers.

- Performance improvements if an AMI callback object is reused with 
  the same proxy.

- If several proxies share the same connection, and an operation call
  on one of the proxies causes a failure and the shared connection to
  be closed, then subsequent calls on the other proxies will try to
  establish a new connection instead of throwing an exception, even if
  retries are disabled.

- Fixed bug in identityToString() and proxyToString() that could
  cause incorrect string values to be returned for identities
  containing characters outside the ASCII range.

- If a proxy is not configured with the -h parameter, Ice will now
  attempt to connect using all local interfaces. The loopback
  interface (127.0.0.1) will only be tried if it is the only local
  interface present.

- createReverseProxy() and createProxy() did not use the default
  context established on the communicator and created a proxy with an
  empty context instead. This has been fixed.

Changes since version 3.0.0
---------------------------

- The contents of the default context set on a communicator were
  ignored, so an empty default context was marshaled. Fixed this.
 
- Changed the ObjectPrx.equals() method to eliminate the possibility
  of a ClassCastException.

- Fixed a bug in endpoint comparisons that would cause new connections
  to be created needlessly. This would occur when the representation
  of the host differed between the proxy and endpoint configuration,
  with one containing the hostname and the other the numeric host
  address.

- Fixed a bug in the Slice parser that caused problems if an included
  file contained white space in the file name.

- Fixed bug where ObjectAdapter.createProxy() didn't create indirect
  proxies with the object adapter replica group id.

Changes since version 2.1.2
---------------------------

- Added support for custom comparison in Freeze Maps. You can now
  provide your own Comparator object for keys and indices. The
  constructor for a generated Freeze Map takes two new optional
  parameters: a Comparator object (the comparator for the primary key)
  and a java.util.Map string-to-Comparator, which provides the 
  Comparators for the indices. When the comparator is null or not
  provided, Freeze compares binary strings encoded using the Ice 
  encoding.

  Freeze Map now implements the java.util.SortedMap interface, and
  also provides four new non-standard methods:

   - SortedMap headMapForIndex(String indexName, Object toKey)
   - SortedMap mapForIndex(String indexName)
   - SortedMap subMapForIndex(String indexName, Object fromKey,
			      Object toKey)
   - SortedMap tailMapForIndex(String indexName, Object fromKey)
  
  The returned SortedMap is a map index-key to java.util.Set of 
  Map.Entry objects of the main Freeze Map.

  The following code is similar but not identical to using
  map.findByFoo(bar):

  ((java.util.Set)map.subMapForIndex("foo").get(bar)).entrySet().iterator()

  In particular:

  * the parameter ("bar") must be an Object (not a byte or int for
    example)

  * get(bar) returns null if there is no entry with this index, while
    findByFoo() always returns an iterator (sometimes with 0 elements)

- Fixed a deadlock during shutdown that could happen with
  bi-directional connections.

- Removed ice_default() method from proxies.

- Connection::close(false) (i.e., graceful connection shutdown) now
  waits until all outstanding requests have completed.

- Added a new object adapter property, <adapter>.ReplicaGroupId, which
  allows adapters to be replicated. See the IceGrid chapter in the
  manual for more information.

- Added the proxy method ice_connectionId, which allows an application
  to control connection reuse.

- Added the new methods Ice.Util.initializeWithLogger() and
  Ice.Util.initializeWithPropertiesAndLogger(), which ensure that a
  custom logger is used to record any errors during communicator
  initialization.

- Ice will now listen on all local interfaces if no -h parameter is
  present in the endpoint configuration and no default host has been
  set. It will also listen to all interfaces if the -h parameter is
  set to 0.0.0.0. In such configurations the endpoints published in
  proxies will not contain the loopback interface (127.0.0.1) unless
  it is the only local interface present.

- The Freeze implementation now uses the new BerkeleyDB Java API
  introduced in version 4.3. BerkeleyDB 4.2 is no longer supported.

- The mapping for structures has changed: the clone() method now has
  an empty exception specification; previously, it could throw
  java.lang.CloneNotSupportedException.

- Changed the way servant locators work if a server has a servant
  locator registered for a specific category, in addition to a default
  servant locator. Previously, if the locator for the specific
  category failed to locate the servant, the run time would then call
  the default locator. With the new behavior, if the locator for the
  specific category does not return a servant, the default locator is
  not called.

- Added proxy methods to retrieve the proxy adapter id and endpoints
  (ice_getAdapterId() and ice_getEndpoints()) and to create a new
  proxy with a new adapter id or new endpoints (ice_newAdapterId() and
  ice_newEndpoints()).

- Fixed a bug that would cause UDP server connections to be closed on
  transient errors, thus preventing the reception of any more UDP
  messages until a server restart.

- Communicator::setDefaultContext() no longer changes the context
  information set on existing proxies.

- Ice.Communicator.createObjectAdapter() throws
  Ice.AlreadyRegisteredException if it is called with the name of an
  object adapter that already exists.

- Fixed a bug in the slice2java code generator, which would cause
  incorrect code to be generated when metadata was used to modify
  dictionary types used as class or struct members.

- Renamed CompressionNotSupportException to a more general
  FeatureNotSupportedException.

- Added ice_communicator() to proxies. This function returns the
  communicator that was used to create the proxy.

- Added ice_toString() to proxies. This function returns the
  stringified proxy. This function can be more convenient to use than
  communicator.stringToProxy() because you do not need the
  communicator to stringify a proxy that way.

- Parsing a stringified proxy no longer completely fails if the proxy
  contains an endpoint type that is unknown to the Ice runtime as long
  as the proxy contains other endpoints that are known. A warning is
  printed for the unknown types that are encountered.

- Ice.ObjectImpl is now an abstract class that cannot be instantiated.
  This change should be transparent to application code.

- Added new features to the Java mapping:

  - Structures, classes, and exceptions now have one-shot
    constructors. For example, for a class

      class Example {
          int i;
	  string s;
      };

    the following constructors are generated:

      public class Example extends Ice.ObjectImpl {
	  public Example() { /* ... */ }
	  public Example(int i, String s) { /* ... */ }
	  // ...
      }

    This allows you to construct a structure, class, or exception and
    supply values for the data members in a single statement, instead
    of having to assign to the members of a default-constructed
    instance.

    For derived exceptions and classes, the constructor expects values
    for all data members, including those of base exceptions or
    classes, in base-to-derived order of declaration.

Changes since version 2.1.1
---------------------------

- Fixed a bug in proxyToString() for bidirectional proxies.

- Fixed a bug with dynamic thread pools, where new threads were
  destroyed immediately after dispatch if <threadpool>.Size=1 and
  <threadpool>.SizeMax > 1.

- Added the configuration property Ice.Compression.Level to provide
  more control over the bzip2 algorithm used to compress Ice protocol
  messages.

Changes since version 2.1.0
---------------------------

- Modified the Ice marshaling engine so that references to Ice objects
  are released as soon as possible.

- Fixed a race condition that could cause a process to abort during
  shutdown.

- Added sequences of fixed-length elements to throughput demo.

- Fixed a bug that could cause an assert if connections could not be
  established in thread-per-connection mode.

- Added two new properties for controlling Active Connection
  Management (ACM). In prior releases ACM was governed by the property
  Ice.ConnectionIdleTime, which affected client- and server-side
  behavior. The new properties, Ice.ACM.Client and Ice.ACM.Server,
  now allow independent timeouts to be specified for client- and
  server-side ACM. Ice.ConnectionIdleTime is now deprecated.

- Reverted a change introduced in 2.1.0 in which retries were not
  attempted for oneway and batch oneway requests. Ice now behaves
  as it did in prior releases: if the connection associated with a
  oneway or batch oneway proxy is closed, an invocation on the proxy
  will transparently reestablish the connection. Please see the Ice
  manual for more information on the reliability of oneway and batch
  oneway reliability.

- Ice::ObjectNotExistException is now retried for invocations made on
  indirect proxies. This allows the transparent migration of objects
  or objects adapters.

- Changed the IceBox.ServiceManagerI class to be inheritable and its
  run() method to be public.

- Fixed a bug in the option parsing for Ice tools such as slice2cpp,
  slice2java, slice2cs, etc. The option parser used to incorrectly
  complain about repeated options when in fact no option was repeated.
  Also changed the parser to permit options to follow an argument, so

      slice2cpp -I. x.ice

  and

      slice2cpp x.ice -I.

  are now equivalent.

- Added -E option to the various Slice compilers to print preprocessor
  output on stdout.

- As announced with version 1.5, slice2java and slice2freezej now
  require all Slice definitions to be nested inside a module;
  definitions at global scope (other than module definitions) now
  cause a hard error (whereas, previously, they only caused a
  warning).

Changes since version 2.0.0
---------------------------

- The Java build system now requires Apache ant version 1.6.2 or greater.

- We do not retry oneway or batch oneway requests anymore, except if
  there are problems during connection establishment. If we retry a
  oneway or batch oneway, previous oneways from the same batch, or
  previous oneways that are buffered by the IP stack implementation,
  are silently thrown away. This can lead to a situation where the
  latest oneway succeeds due to retry, but former oneways are
  discarded.

- Fixed race between connection validation and activation for UDP
  endpoints in thread-per-connection mode.

- Fixed a deadlock that could occur if a server cannot send data
  during connection validation.

- Metadata is now allowed for dictionary types.

- Added support for SSL. The Java plug-in uses the SSL capabilities
  provided by Java 1.4.2. As such, the plug-in is not compatible with
  the Ice thread pool, therefore the property Ice.ThreadPerConnection=1
  must be defined for any communicator in which the plug-in is
  installed. See the Ice manual for more information.

- Added an optimization to the Freeze evictor for the ice_ping
  operation. The object is no longer loaded into the cache by this
  operation; Freeze simply checks if the object is in the cache or
  the database.

- Added setDefaultContext() and getDefaultContext() to the
  Ice.Communicator interface. This allows a default context to be
  established on a communicator-wide basis. See section 29.9.3 in
  the doc.

  Added ice_defaultContext to Ice.ObjectPrx. This creates a new
  proxy that uses the default context established on the communicator.

- Overloaded the checkedCast member function of the generated proxy
  helper classes to allow a trailing argument of type Ice::Context.
  This makes it possible to do stateful things that require a context
  in a servant locator's activate() method.

- Added support for bzip2 protocol compression. The implementation
  uses the bzip2 classes from Ant. See the INSTALL file for more
  information.

Changes since version 1.5.1
---------------------------

- The proxy returned by the object adapter operations addFacet and
  addFacetWithUUID did not contain the facet. This required the
  application to make an extra call to ice_newFacet in order to
  obtain the correct proxy. This has been fixed.

- Added the object adapter property <name>.PublishedEndpoints, which
  specifies endpoints to advertise in proxies created by the adapter.

- Fixed a bug with AMD exception handling, where it was possible that
  certain exceptions propagate out of ice_response() or
  ice_exception(), and therefore such exceptions were not handled
  properly.

- Exceptions raised while marshaling data for batch requests resulted
  in a connection deadlock. This has been fixed.

- Fixed tracing of operation mode.

- Fixed a bug that caused marshaling failures when global metadata was
  used to define an alternate Java package. Two new properties are
  supported: Ice.Package.* and Ice.Default.Package. See the manual for
  more information.

- Fixed bug in slice2java: with the --impl-tie option, incorrect code
  was generated for local interfaces and classes.

- Changed code generation in slice2java: for local interfaces, only an
  OperationsNC (but no Operations) interface is generated
  now. (Previously, both interfaces were generated, with one of them
  being empty.)

- Freeze dictionaries now support indices. You can index on the full
  value of the dictionary, or on a member (when the value is a struct
  or a class). When you index on a member, you can define several
  indices (for different members). See the Freeze bench demo and the
  Freeze dbmap test for examples.

- Fixed the slice2java compiler for operations with multiple
  exceptions in an exception specification: if an exception was a base
  of one or more other exceptions in the same exception specification,
  the code generator sometimes emitted the catch blocks in the
  marshaling and dispatch code in the wrong order. (This applied only
  to interfaces with an ["amd"] metadata directive.)

- The documentation has always stated that same-named constructs
  cannot be directly nested inside each other. (For example, a module
  `M' cannot contain a constant named `M'. The slice2java compiler did
  not enforce this correctly up to now for modules containing
  constructs with the same name as the enclosing module.  This has
  been fixed and now results in a diagnostic.

- The slice2java compiler now deprecates Slice definitions at global
  scope: only modules can be defined at global scope. Everything else
  (constants, classes, interfaces, etc.) must be defined inside a
  module.

  For the time being, the compiler issues a warning for each global
  definition but continues to compile the code. Global non-module
  definitions will elicit a hard error two releases from now.

- Several demos used Slice classes where interface were more
  appropriate. This has been fixed.

- Ice.Util.initializeWithProperties() now correctly parses the command
  line arguments.

- Fixed a bug in slice2java that caused byte constants to be
  initialized incorrectly.

- For classes with operations, the code generator now generates
  overloaded methods for each operation, one exactly as before, and
  another one without the trailing Ice.Current parameter.  For
  example:

  // Slice
  class Foo
  {
      void op();
  };

  // Java
  public abstract class Foo extends Ice.ObjectImpl
                            implements _FooOperations, _FooOperationsNC
  {
      public final void
      op()
      {
          op(null);
      }
  }

  public interface _FooOperations
  {
      void op(Ice.Current __current);
  }

  public interface _FooOperationsNC
  {
      void op();
  }

  This change allows you to call an operation on a class without
  having to supply a null dummy argument:

  Foo f = new FooI();
  f.op(null);		// Previously, null had to be passed. This still works.
  f.op();		// OK as of now.

- New properties Ice.StdErr and Ice.StdOut to redirect the standard
  error and output streams of a process.

Changes since version 1.5.0
---------------------------

- No changes between 1.5.0 and 1.5.1.

Changes since version 1.4.0
---------------------------

- Added support for generating checksums of Slice definitions,
  enabling peers to verify that they share the same client-server
  contract. See the manual for more information.

- Fixed a bug that could cause an assert or exception in some rare
  circumstances, if an operation is invoked after the object adapter
  for the Ice object has been deactivated.

- Fixed a bug that could cause a NullPointerException while
  unmarshaling a sequence of objects containing a null element.

- Changed the mapping for tie classes, which now implement the
  interface Ice.TieBase. This interface defines the ice_delegate
  methods and changes the delegate type from _FooOperations to
  java.lang.Object.

- Changed the --depend option of slice2java. If you get dependencies
  for a file x.ice that includes y.ice, the dependency line that is
  written now is "/path/x.ice: /path/y.ice". (Previously, it was
  "x.cpp: /path/x.ice /path/y.ice".) With some post-processing, this is
  sufficient to generate dependencies for tools such as ant and make.

Changes since version 1.3.0
---------------------------

- Fixed a bug when making asynchronous invocations on a routed proxy.

- Changed the way sequences are unmarshaled to protect against
  malicious messages with faked very large sequence count values.
  While even with previous versions of Ice, buffer overruns were
  impossible, malicious messages could cause large amounts of memory
  to be preallocated, causing the receiving process to run out of
  memory. This is no longer possible -- the total amount of memory
  preallocated for sequences during unmarshaling is now capped at
  Ice.MessageSizeMax.

- Removed a bogus assert that could happen under certain race
  conditions when a connection timeout occurs.

- Added checkedCast and uncheckedCast operations to ObjectPrxHelper.

- Assertions in servant methods are now correctly caught and an error
  message is printed using the logger.

- Facets have been significantly redesigned.

  * Facets are no longer hierarchical. As a result, FacetPath (which
    was a sequence of strings) is now simply a string. This is
    reflected in all APIs that used FacetPath.

  * There is no longer an active facet map in Ice::Object. As a
    result, the following operations have been removed:

    + On proxies: ice_facets, ice_appendFacet.

    + On Object: ice_facets, ice_addFacet, ice_removeFacet,
      ice_updateFacet, ice_removeAllFacets, ice_findFacet,
      ice_findFacetPath.

  * The object adapter is now used to register facets instead of the
    active facet map. The following operations have been added to
    Ice::ObjectAdapter: addFacet, addFacetWithUUID, removeFacet,
    removeAllFacets, findFacet, and findAllFacets.

    Please see the reference manual for more information. For naming
    consistency, the following object adapter operations have been
    renamed:

    + identityToServant has been renamed to find.
    + proxyToServant has been renamed to findByProxy.

  * This object model design change means that facets are no longer
    transferred with an object sent by value.

  * If your application receives an object with facets from an older
    version of Ice, a MarshalException is raised. This is unavoidable
    because it is a change to the object model, and not just to the
    way objects are transferred or encoded.

  * If your application receives a request or reply with a facet path
    with more than one element, the run time throws a MarshalException.

  * If your application receives a proxy with a facet path with
    more than one element, the run time throws ProxyUnmarshalException.

- Ice no longer retries operation calls on RequestFailedException.
  (ObjectNotExistException, OperationNotExistException, and
  FacetNotExistException are derived from RequestFailedException.)

- Fixed a bug with certain cached objects not being destroyed when
  connections are closed.

- Added ConnectionRefusedException as a specialization of
  ConnectFailedException, to indicate if a connection fails because a
  server actively refuses the connection.

- Fixed the slice2java compiler for operations with multiple
  exceptions in an exception specification: if an exception was a base
  of one or more other exceptions in the same exception specification,
  the code generator sometimes emitted the catch blocks in the
  marshaling and dispatch code in the wrong order.

Changes since version 1.2.0
---------------------------

- Added Slice interface Ice::Process in slice/Ice/Process.ice. This
  interface enables IcePack to properly shut down a process without
  relying on signals, which is necessary for successful operation
  on Windows.

- Added setServerProcessProxy to Ice::LocatorRegistry.

- Added new properties <ObjectAdapter>.RegisterProcess and
  Ice.ServerId. If RegisterProcess is defined, the object adapter
  creates a servant implementing the Ice::Process interface and
  registers it with the locator registry using the server id
  defined by Ice.ServerId.

- Added the "register" attribute to the <adapter> element in the
  IcePack descriptors. If true, the RegisterProcess property is
  defined for the object adapter.

- Added getLocator to ObjectAdapter.

- Added the methods ice_preMarshal and ice_postUnmarshal to
  Ice.Object. The default implementations do nothing, but subclasses
  may override them to take special action before marshaling and
  after unmarshaling, respectively.

- Added the demo/IcePack/simple example.

- Connections are no longer closed when the last proxy using the
  connection is destroyed. Doing so is error prone:

  * Quite often, proxies are created on the fly, resulting in
    connections being opened and closed all the time. This is
    especially true for services that receive a proxy and data, and
    then forward this data using the proxy.

  * Often, connections are stay open for too long, because proxies are
    kept even though they are never used again.

  * It doesn't work well with AMI requests, because the AMI callback
    objects keep track of connections directly. This would mean that
    if a process only uses AMI requests, a connection is opened and
    closed for each request, as each request typically has its own
    AMI callback object.

  Instead, ACM (Automatic Connection Management) is now enabled by
  default, with a default value of one minute. This means that idle
  connections are closed after one minute, regardless of whether there
  are proxies using the connection or not. This closing of connections
  is transparent, i.e., closed connections are automatically
  reestablished in case they are needed again. Please see the
  description of the Ice.ConnectionIdleTime property for details.

- ACM has been completely reworked. It now works properly with respect
  to retrying failed requests.

- Added the IceBox.LoadOrder property, which specifies the order
  in which IceBox services are loaded.

- Added support for Berkeley DB 4.2.52.

- The default thread pool size is now just one thread. This is the
  fastest possible setting, still allows one level of nesting, and
  doesn't require that servants be thread safe. (Please see the
  description of the thread pool properties in the manual for
  information on how to increase the number of threads.)

- Fixed a problem with servers not shutting down properly under
  certain circumstances.

- Fixed a rare connection deadlock, that could happen if lots of long
  messages are sent rapidly in parallel, using separate threads or
  AMI.

- Ported demo/IcePack/hello from C++.

- Added new mechanism for generating Java code into packages.
  The global metadata prefix "java:package:" now specifies the
  package for all types in a Slice file. For example, the metadata
  [["java:package:com.zeroc"]] causes all of the classes to be
  generated in the com.zeroc package. The --package option is no
  longer supported by the translator, and the slice2java ant task
  has been changed accordingly.

- Changed the metadata prefix for specifying custom sequence types.
  The new prefix is "java:type:", to be consistent with the new
  package metadata described above. The old prefix "java:" is now
  deprecated.

- Added test/Ice/translator to exercise the translator's support
  for packages.

- Errors during close() or shutdown() on connections now cause
  exceptions.

- Fixed a deadlock that could happen if requests were sent from the
  exception() AMI callback.

- New Freeze.Warn.CloseInFinalize property. When this property is 
  set to a value greater than 0, a warning is issued when a live 
  iterator is closed by a finalizer. The default value is 1.
  To see this warning in programs that do not run very long or do 
  not create a large number of objects, it may be necessary
  to explicitly call the JVM garbage collector with System.gc().

- Added property Ice.Override.ConnectTimeout. See the manual for
  details.

- Fixed a rare deadlock in the object adapter, when a locator was
  used.

- A DNSException could cause a deadlock. This has been fixed.

- The Ice.Stats interface was not being invoked by the TCP and
  UDP transports. This has been fixed.

Changes since version 1.1.1
---------------------------

- Manual retry in the exception() callback of asynchronous requests
  didn't work. This has been fixed.

- Fixed a crash that could happen during shutdown.

- Fixed a deadlock that could happen during connection establishment.

- Fixed deadlock during shutdown that can happen if a thread pool with
  only one thread is used.

- Moved UserExceptionFactory from Ice package to IceInternal package
  because UserExceptionFactory is no longer an interface for use
  by applications.

- Bi-directional connections are now handled by the client-side thread
  pool instead of the server-side thread pool.

- Fixed a bug in the generated code that caused "at-most-once"
  semantics to be ignored for collocated invocations.

- Fixed ant tasks to use ICE_HOME (if defined) in the pathname of
  a translator executable.

- Implemented TwowayOnlyException. That exception is raised if an
  attempt is made to invoke an operation that has a return value,
  out parameters, or an exception specification via a oneway or
  datagram proxy.

- Removed ice_flush() on the proxy base class. Batch requests are
  now flushed by calling Communicator::flushBatchRequests(). This
  flushes all requests that are currently batched in the communicator,
  (for all connections).

- Added back the connection closure timeout, but only for misbehaving
  peers. If a timeout is set, and a peer doesn't react to a close
  connection message, the connection is forcefully closed after the
  timeout. However, it is never forcefully closed if requests are
  still outstanding. Doing so would violate ordering guarantees for
  finished() and deactivate() on servant locators.

- Fixed a bug in the slice2java code generator: if a parameter was
  named "current", illegal code was generated.

- Fixed a bug in the slice2java code generator: tie classes were not
  generated correctly for operations with an "amd" metadata directive.

- Fixed a bug where Ice would print a dispatch warning for
  Ice::RequestFailedException even if the Ice.Warn.Dispatch property
  was set to 1.

- Added per-proxy contexts. The change is source-code compatible with
  the previous approach, that is, it is still possible to pass an
  explicit Ice::Context to an operation call as an additional,
  trailing parameter. However, Ice.ObjectPrx now contains two
  new operations:

  - ice_getContext()

    This returns the context currently associated with a particular
    proxy. (By default, the context associated with proxies is empty.)

  - ice_newContext(java.util.Map context)

    This creates a new proxy that is associated with the passed
    context. Thereafter, calls via the new proxy always pass the
    context that was passed to ice_newContext() when that proxy was
    created.

  The net effect of this is that it is now possible to establish the
  context for a proxy once and, thereafter, have that same context
  sent automatically whenever an operation is invoked via the proxy
  (instead of having to pass an explicit context parameter on every
  call).

- Added Ice::Properties::parseIceCommandLineOptions(). This operation
  converts to properties all options that start with one of the
  following prefixes: --Ice, --IceBox, --IcePack, --IcePatch,
  --IceSSL, --IceStorm, --Freeze, and --Glacier.

- Added menu with several options to throughput demo.

- Major Freeze update. See corresponding entry in the Ice for C++
  CHANGES file.

- Added Ice.UDP.RcvSize and Ice.UDP.SndSize properties. These
  properties control the size of the UDP receive and send buffers as
  well as controlling the maximum size of a datagram invocation. If a
  datagram exceeds the configured size, the Ice run time throws a
  DatagramLimitException. (Note that, on the receiving size, detection
  of this condition is dependent on the local UDP implementation --
  some UDP implementations silently drop datagrams that are too large
  to fit into the receive buffer instead of reporting the error or
  delivering a truncated datagram.)

- Added Ice.Warn.Datagrams. This property prints a warning on the server
  side if a DatagramLimitException is thrown.

- Added Ice.MessageSizeMax property. This property controls the
  maximum message size accepted by the Ice protocol in kiloBytes. The
  default value is 1024 (1 MB).

- Fixed a number of incorrect property settings in the config files
  for the demos.

- Changed the return type of the ice_invoke_async method in
  Ice.BlobjectAsync to void instead of boolean.

- Added new property: Ice.Trace.Slicing. When set to a value > 0,
  unknown exception and class types that are sliced emit a warning.

- Added destroyOnInterrupt() to the Application
  class. destroyOnInterrupt() is now the default behavior, because
  shutdownOnInterrupt() only shuts down the server side of an
  application, and therefore doesn't work with pure clients.

- ObjectAdapter::removeServantLocator() no longer exists.  The life
  cycle of servant locators that are registered with an object adapter
  ends when the adapter is destroyed.

- Changed Ice::ServantLocator::deactivate to be passed the category
  for which a servant locator is being deactivated.

- Added saveObject() operation on Evictor, and savedObject() operation
  on PersistenceStrategy.

  saveObject() saves a persistent object immediately. Once an
  operation has called saveObject(), the object is considered "clean":
  other updates by the same operation can only be reliably saved by
  another call to saveObject().

- Added a test to the property parsing code to print a warning on
  System.err if a property is not recognized. This prevents silly
  typos, such as "Ice.config=MyFile" (instead of "Ice.Config=MyFile")
  from slipping through undetected.

- Changed the python code for printing output from test clients, so
  that you get each line as it comes.

Changes since version 1.1.0
---------------------------

- Added support for a default object factory, similar to the semantics
  of servant locators. Specifically, a factory registered with an
  empty type id is invoked when a type-specific factory cannot be
  found.

- Fixed a bug where the locator cache wasn't correctly updated upon a
  connection failure to a server. This was causing IceJ to try to
  re-establish the connection to the same server endpoints without
  asking the locator if eventually the endpoints had changed.

- Fixed server side bug with batch oneways or batch datagrams.

- Fixed a bug where the operation mode argument wasn't used in the
  implementation of the Ice.ObjectPrx ice_invoke method.

- Added missing declaration for ice_invoke_async to Ice.ObjectPrx.

- Fixed a bug in the generated code for custom sequences so that it
  now checks whether the sequence value is null.

- Added DB_PRIVATE flag to DBEnv->open(), to be able to use the
  Berkeley DB that ships with RedHat 9.

Changes since version 1.0.1
---------------------------

- Ice now implements slicing for exceptions and classes: if a process
  receives an exception or class that is of a more derived type than
  the receiver understands, the exception or class is automatically
  sliced. (Previously, this situation resulted in an exception.)

- User exception factories and user exception factory
  managers no longer exist. The factories for user exceptions
  are now automatically installed by the Ice run time.
  If you have existing code that implements user exception factories,
  you can simply delete it.

- Fixed a bug in the Slice parser: the semantic check to see
  whether an identifier introduced into a scope has changed
  meaning was too stringent.

- Fixed a bug with connections being closed even though they have
  outstanding batch requests.

- The "unknown" field in UnknownLocalException and UnknownException
  now contains the whole exception stack trace instead of just the
  exception name.

- Replaced the Freeze::EvictorPersistenceMode enumeration with the
  interface Freeze::PersistenceStrategy.

- Instead of aborting the caller thread, Ice for Java now catches
  assertions in servant methods, prints the assertion, closes the
  connection, and continues.

- Added dynamic thread pools, i.e., thread pools that grow and shrink
  based on a calculated load factor. Please see the section about thread
  pools in the manual for further details.

- Structs and sequences which hold other structs or sequences are now
  legal dictionary key types, as long as such nested structs or sequences
  are (recursively) legal.

- The connection timeout is now also used when connections are
  closed. This avoids hanging processes if the peer misbehaves, or if
  asynchronous method invocations do not return.

- In some cases, communicator destruction could result in a
  java.lang.NullPointerException. This has been fixed. Now a
  CommunicatorDestroyedException is raised.

- Fixed a bug with AMD methods using a servant locator, such as the
  Freeze evictor.

- Changed the generated equals() method to use the helper
  java.util.Arrays.equals() when comparing sequences, rather than the
  native array equals() method. This means the equals() method for a
  type containing a sequence member will perform a deep comparison of
  the sequence.

- Added timestamps to the default Ice logger. You can enable
  timestamps by setting the `Ice.Logger.Timestamp' property to a value
  larger than zero. By default timestamps are disabled.

- Improved IceBox service deactivation. Instead of successively
  stopping a service and destroying its communicator, services are now
  all stopped first and then their communicators are destroyed.

- Modified the Ice protocol to marshal sizes more efficiently.
  Sizes less than 255 now require a single byte whereas
  previously, sizes between 127 and 254 required five bytes.

- Modified the Ice protocol to fix a problem with compression. The
  compressed message types have been removed, and a field has been
  added to the message header indicating compression status.

- Added version negotiation to the Ice protocol. This permits future
  protocol extensions to be added without breaking interoperability
  with older deployed clients and servers. Unfortunately, doing this
  broke compatibility with the existing protocol so, when upgrading to
  this version, you must make sure that clients and servers use the
  same version of Ice.jar.

- Added a magic number to the Ice protocol. All Ice protocol messages
  have 'I', 'c', 'e', 'P' (encoded as ASCII) in the first four bytes.
  This is useful to allow protocol analyzers to recognize Ice
  messages.

- Changed the encoding of encapsulations. An encapsulation now looks
  like:

	size (4 bytes)
	major version number (1 byte)
	minor version number (1 byte)
	data (n bytes)

  The size includes the count of bytes for the size and versions, so
  the value of size is n + 6.

- Added -v and -e options to stringified UDP endpoints. -v sets the
  protocol version and -e sets the encoding version. (The current
  version for both protocol and encoding is 1.0.)

Changes since version 1.0.0
---------------------------

- Fixed a bug in the ObjectAdapter which caused it to ignore all but
  the first endpoint.

- Fixed a bug with throwing exceptions in AMD calls after invoking
  ice_response().

- Fixed a bug with throwing exceptions in AMI from within
  ice_response().


